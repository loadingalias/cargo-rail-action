name: "cargo-rail"
description: "Graph-aware change detection for Rust monorepos. Check/Test/Bench/Profile only what actually changed."
author: "loadingalias"

branding:
  icon: "git-branch"
  color: "orange"

inputs:
  version:
    description: "cargo-rail version to install (default: latest)"
    required: false
    default: "latest"

  since:
    description: "Git ref to compare against (auto-detects PR base or origin/main)"
    required: false

  command:
    description: "Command to run: affected/test (default: affected)"
    required: false
    default: "affected"

  args:
    description: "Additional arguments to pass to cargo-rail"
    required: false
    default: ""

  working-directory:
    description: "Working directory containing Cargo.toml (default: repo root)"
    required: false
    default: "."

  token:
    description: "GitHub token for downloading releases"
    required: false
    default: ${{ github.token }}

outputs:
  # Primary Outputs
  crates:
    description: "Space-separated list of affected crates"
    value: ${{ steps.affected.outputs.crates }}

  cargo-args:
    description: "Cargo -p flags for direct use: -p crate1 -p crate2"
    value: ${{ steps.affected.outputs.cargo_args }}

  count:
    description: "Number of affected crates"
    value: ${{ steps.affected.outputs.affected_count }}

  matrix:
    description: "JSON array for strategy.matrix.crate (use with fromJson)"
    value: ${{ steps.affected.outputs.test_matrix }}

  # Classification Flags
  docs-only:
    description: "'true' if only documentation files changed (skip tests)"
    value: ${{ steps.affected.outputs.docs_only }}

  rebuild-all:
    description: "'true' if infrastructure files changed (test everything)"
    value: ${{ steps.affected.outputs.rebuild_all }}

  # Detailed Breakdown
  direct:
    description: "Space-separated crates with direct file changes"
    value: ${{ steps.affected.outputs.direct }}

  transitive:
    description: "Space-separated crates affected via dependencies"
    value: ${{ steps.affected.outputs.transitive }}

  changed-files:
    description: "Number of changed files"
    value: ${{ steps.affected.outputs.changed_files_count }}

  infrastructure-files:
    description: "JSON array of infrastructure files that triggered rebuild_all"
    value: ${{ steps.affected.outputs.infrastructure_files }}

  custom-categories:
    description: "JSON object of custom category matches from rail.toml"
    value: ${{ steps.affected.outputs.custom_categories }}

  # Installation Metadata
  install-method:
    description: "How cargo-rail was installed (binary, binstall, cargo-install, cached)"
    value: ${{ steps.install.outputs.method }}

  cargo-rail-version:
    description: "Installed cargo-rail version"
    value: ${{ steps.install.outputs.version }}

runs:
  using: "composite"
  steps:
    # Install; Cached > Binary Download > Cargo-Binstall > Cargo Install
    - name: Install cargo-rail
      id: install
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        REQUESTED_VERSION: ${{ inputs.version }}
      run: |
        set -euo pipefail

        # Check if already installed and meets version requirement
        if command -v cargo-rail &>/dev/null; then
          INSTALLED_VERSION=$(cargo-rail rail --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "unknown")
          if [[ "$REQUESTED_VERSION" == "latest" || "$INSTALLED_VERSION" == "$REQUESTED_VERSION" ]]; then
            echo "cargo-rail $INSTALLED_VERSION already installed"
            echo "method=cached" >> "$GITHUB_OUTPUT"
            echo "version=$INSTALLED_VERSION" >> "$GITHUB_OUTPUT"
            exit 0
          fi
        fi

        # Determine target triple from runner environment
        case "$RUNNER_OS-$RUNNER_ARCH" in
          Linux-X64)   TARGET="x86_64-unknown-linux-gnu" ;;
          Linux-ARM64) TARGET="aarch64-unknown-linux-gnu" ;;
          macOS-X64)   TARGET="x86_64-apple-darwin" ;;
          macOS-ARM64) TARGET="aarch64-apple-darwin" ;;
          Windows-X64) TARGET="x86_64-pc-windows-msvc" ;;
          *)
            echo "::warning::Unknown platform $RUNNER_OS-$RUNNER_ARCH, will try cargo install"
            TARGET=""
            ;;
        esac

        # Resolve version (latest -> actual version number)
        VERSION="$REQUESTED_VERSION"
        if [[ "$VERSION" == "latest" ]]; then
          VERSION=$(gh api repos/loadingalias/cargo-rail/releases/latest --jq '.tag_name' 2>/dev/null | sed 's/^v//' || echo "")
          if [[ -z "$VERSION" ]]; then
            echo "::warning::Could not determine latest version from GitHub API"
          fi
        fi

        # Fast path: Pre-built binary download
        if [[ -n "$TARGET" && -n "$VERSION" ]]; then
          echo "Attempting binary download: cargo-rail v$VERSION for $TARGET"

          if [[ "$RUNNER_OS" == "Windows" ]]; then
            ARCHIVE="cargo-rail-${TARGET}.zip"
          else
            ARCHIVE="cargo-rail-${TARGET}.tar.gz"
          fi

          URL="https://github.com/loadingalias/cargo-rail/releases/download/v${VERSION}/${ARCHIVE}"
          INSTALL_DIR="$HOME/.cargo/bin"
          mkdir -p "$INSTALL_DIR"

          if curl -fsSL --retry 3 "$URL" -o "/tmp/$ARCHIVE"; then
            echo "Downloaded $ARCHIVE"
            echo "Extracting to $INSTALL_DIR..."

            if [[ "$RUNNER_OS" == "Windows" ]]; then
              unzip -q "/tmp/$ARCHIVE" -d "/tmp/cargo-rail-extract"
              mv /tmp/cargo-rail-extract/cargo-rail.exe "$INSTALL_DIR/"
            else
              tar -xzf "/tmp/$ARCHIVE" -C "/tmp"
              # Handle both flat and nested archive structures
              if [[ -f "/tmp/cargo-rail" ]]; then
                mv /tmp/cargo-rail "$INSTALL_DIR/"
              elif [[ -f "/tmp/cargo-rail-${TARGET}/cargo-rail" ]]; then
                mv "/tmp/cargo-rail-${TARGET}/cargo-rail" "$INSTALL_DIR/"
              else
                echo "::error::Binary not found after extraction. Contents of /tmp:"
                ls -la /tmp/cargo-rail* 2>/dev/null || echo "No cargo-rail files found"
                exit 1
              fi
              chmod +x "$INSTALL_DIR/cargo-rail"
              echo "Binary installed to $INSTALL_DIR/cargo-rail"
            fi

            rm -rf "/tmp/$ARCHIVE" "/tmp/cargo-rail-extract" "/tmp/cargo-rail" "/tmp/cargo-rail-v"* 2>/dev/null || true

            # Add cargo bin to PATH for this and subsequent steps
            echo "$INSTALL_DIR" >> "$GITHUB_PATH"
            export PATH="$INSTALL_DIR:$PATH"

            # Verify binary works (cargo-rail is a cargo subcommand, use "rail --version")
            if ! "$INSTALL_DIR/cargo-rail" rail --version; then
              echo "::error::cargo-rail binary failed to execute"
              file "$INSTALL_DIR/cargo-rail" || true
              ldd "$INSTALL_DIR/cargo-rail" 2>/dev/null || true
              exit 1
            fi

            INSTALLED_VERSION=$("$INSTALL_DIR/cargo-rail" rail --version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            echo "Installed cargo-rail v$INSTALLED_VERSION from binary"
            echo "method=binary" >> "$GITHUB_OUTPUT"
            echo "version=$INSTALLED_VERSION" >> "$GITHUB_OUTPUT"
            exit 0
          else
            echo "::warning::Binary download failed for $URL"
          fi
        fi

        # Medium path: cargo-binstall (if available)
        if command -v cargo-binstall &>/dev/null; then
          echo "Trying cargo-binstall..."
          BINSTALL_ARGS="--no-confirm --force"
          [[ -n "$VERSION" && "$VERSION" != "latest" ]] && BINSTALL_ARGS="$BINSTALL_ARGS --version $VERSION"

          if cargo binstall cargo-rail $BINSTALL_ARGS 2>/dev/null; then
            INSTALLED_VERSION=$(cargo-rail rail --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            echo "Installed cargo-rail v$INSTALLED_VERSION via cargo-binstall"
            echo "method=binstall" >> "$GITHUB_OUTPUT"
            echo "version=$INSTALLED_VERSION" >> "$GITHUB_OUTPUT"
            exit 0
          fi
        fi

        # Slow path: cargo install (requires Rust toolchain)
        echo "::warning::Falling back to cargo install (this may take 2-5 minutes)"
        INSTALL_ARGS="--locked"
        [[ -n "$VERSION" && "$VERSION" != "latest" ]] && INSTALL_ARGS="$INSTALL_ARGS --version $VERSION"

        cargo install cargo-rail $INSTALL_ARGS

        INSTALLED_VERSION=$(cargo-rail rail --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        echo "Installed cargo-rail v$INSTALLED_VERSION via cargo install"
        echo "method=cargo-install" >> "$GITHUB_OUTPUT"
        echo "version=$INSTALLED_VERSION" >> "$GITHUB_OUTPUT"

    # Detect Base Reference for Comparison; Explicit Input > PR Base > Origin/Main > Origin/Master > HEAD~1
    - name: Detect base ref
      id: base
      shell: bash
      run: |
        INPUT_SINCE="${{ inputs.since }}"

        # Handle null SHA (first push on new branch or force push)
        # GitHub sets before to 0000...0000 in these cases
        if [[ "$INPUT_SINCE" =~ ^0+$ ]]; then
          echo "Null SHA detected (first push or force push), falling back to auto-detect"
          INPUT_SINCE=""
        fi

        if [[ -n "$INPUT_SINCE" ]]; then
          echo "ref=$INPUT_SINCE" >> "$GITHUB_OUTPUT"
          echo "Using provided base: $INPUT_SINCE"
        elif [[ -n "$GITHUB_BASE_REF" ]]; then
          echo "ref=origin/$GITHUB_BASE_REF" >> "$GITHUB_OUTPUT"
          echo "PR detected, using: origin/$GITHUB_BASE_REF"
        elif git rev-parse --verify origin/main &>/dev/null; then
          echo "ref=origin/main" >> "$GITHUB_OUTPUT"
          echo "Using default: origin/main"
        elif git rev-parse --verify origin/master &>/dev/null; then
          echo "ref=origin/master" >> "$GITHUB_OUTPUT"
          echo "Using fallback: origin/master"
        else
          echo "ref=HEAD~1" >> "$GITHUB_OUTPUT"
          echo "::warning::No remote branch found, using HEAD~1"
        fi

    # Run Cargo-Rail Command
    - name: Run cargo-rail
      id: affected
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        COMMAND: ${{ inputs.command }}
        EXTRA_ARGS: ${{ inputs.args }}
        BASE_REF: ${{ steps.base.outputs.ref }}
      run: |
        case "$COMMAND" in
          affected)
            cargo rail affected --quiet --since "$BASE_REF" -f github $EXTRA_ARGS -o "$GITHUB_OUTPUT"
            ;;
          test)
            # For test command, run it but also output affected info
            cargo rail affected --quiet --since "$BASE_REF" -f github $EXTRA_ARGS -o "$GITHUB_OUTPUT"
            cargo rail test --quiet --since "$BASE_REF" $EXTRA_ARGS
            ;;
          unify)
            cargo rail unify --quiet --check -f github $EXTRA_ARGS -o "$GITHUB_OUTPUT" || true
            ;;
          *)
            echo "::error::Unknown command: $COMMAND. Use 'affected', 'test', or 'unify'"
            exit 1
            ;;
        esac

        # Generate cargo_args from crates output (requires cargo-rail 0.2.3+)
        # Transform "crate1 crate2 crate3" to "-p crate1 -p crate2 -p crate3"
        CRATES=$(grep "^crates=" "$GITHUB_OUTPUT" 2>/dev/null | cut -d= -f2 || echo "")
        if [[ -n "$CRATES" ]]; then
          CARGO_ARGS=$(echo "$CRATES" | tr ' ' '\n' | sed 's/^/-p /' | tr '\n' ' ' | sed 's/ $//')
          echo "cargo_args=$CARGO_ARGS" >> "$GITHUB_OUTPUT"
        else
          echo "cargo_args=" >> "$GITHUB_OUTPUT"
        fi

    # Generate Job Summary
    - name: Summary
      if: always()
      shell: bash
      run: |
        {
          echo "## cargo-rail"
          echo ""

          # Installation info
          case "${{ steps.install.outputs.method }}" in
            binary)        INSTALL="Binary download" ;;
            binstall)      INSTALL="cargo-binstall" ;;
            cargo-install) INSTALL="cargo install (compiled)" ;;
            cached)        INSTALL="Already installed" ;;
            *)             INSTALL="Unknown" ;;
          esac

          echo "| | |"
          echo "|---|---|"
          echo "| **Version** | \`${{ steps.install.outputs.version }}\` |"
          echo "| **Install** | $INSTALL |"
          echo "| **Base** | \`${{ steps.base.outputs.ref }}\` |"
          echo ""

          # Results
          DOCS_ONLY="${{ steps.affected.outputs.docs_only }}"
          REBUILD_ALL="${{ steps.affected.outputs.rebuild_all }}"
          COUNT="${{ steps.affected.outputs.affected_count }}"
          CRATES="${{ steps.affected.outputs.crates }}"

          if [[ "$DOCS_ONLY" == "true" ]]; then
            echo "> **Documentation only** - no tests required"
          elif [[ "$REBUILD_ALL" == "true" ]]; then
            echo "> **Infrastructure changed** - full test suite recommended"
            echo ""
            echo "| Changed Files | Affected Crates |"
            echo "|---------------|-----------------|"
            echo "| ${{ steps.affected.outputs.changed_files_count }} | **all** |"
          elif [[ "${COUNT:-0}" == "0" ]]; then
            echo "> **No affected crates** - nothing to test"
          else
            echo "| Changed Files | Affected Crates |"
            echo "|---------------|-----------------|"
            echo "| ${{ steps.affected.outputs.changed_files_count }} | **$COUNT** |"
            echo ""
            echo "**Crates:** \`$CRATES\`"

            DIRECT="${{ steps.affected.outputs.direct }}"
            TRANSITIVE="${{ steps.affected.outputs.transitive }}"
            if [[ -n "$DIRECT" ]]; then
              echo ""
              echo "<details><summary>Direct changes</summary>"
              echo ""
              echo "\`$DIRECT\`"
              echo "</details>"
            fi
            if [[ -n "$TRANSITIVE" ]]; then
              echo ""
              echo "<details><summary>Transitive (via dependencies)</summary>"
              echo ""
              echo "\`$TRANSITIVE\`"
              echo "</details>"
            fi
          fi
        } >> "$GITHUB_STEP_SUMMARY"
