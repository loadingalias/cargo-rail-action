name: "cargo-rail"
description: "Planner-first CI transport for cargo rail plan surfaces and trace output."
author: "loadingalias"

branding:
  icon: "git-branch"
  color: "orange"

inputs:
  version:
    description: "cargo-rail version to install (default: latest)"
    required: false
    default: "latest"

  checksum:
    description: "Checksum verification mode for downloaded binaries: required/if-available/off"
    required: false
    default: "required"

  since:
    description: "Git ref to compare against (auto-detects PR base or origin/main)"
    required: false

  args:
    description: "Additional arguments to pass to cargo-rail"
    required: false
    default: ""

  working-directory:
    description: "Working directory containing Cargo.toml (default: repo root)"
    required: false
    default: "."

  token:
    description: "GitHub token for downloading releases"
    required: false
    default: ${{ github.token }}

  mode:
    description: "Output mode: minimal (default) or full (compatibility)"
    required: false
    default: "minimal"

outputs:
  # Planner-native contract
  files:
    description: "JSON array of changed workspace-relative file paths"
    value: ${{ steps.plan.outputs.files }}

  direct-crates:
    description: "Space-separated direct impacted crates"
    value: ${{ steps.plan.outputs.direct_crates }}

  transitive-crates:
    description: "Space-separated transitive impacted crates"
    value: ${{ steps.plan.outputs.transitive_crates }}

  surfaces:
    description: "JSON object of surface decisions (enabled + reasons)"
    value: ${{ steps.plan.outputs.surfaces }}

  plan-json:
    description: "Compact planner payload"
    value: ${{ steps.plan.outputs.plan_json }}

  trace:
    description: "Planner trace payload"
    value: ${{ steps.plan.outputs.trace }}

  # Convenience projections (pure projections of planner output)
  build:
    description: "'true' when build surface is active"
    value: ${{ steps.plan.outputs.build }}

  test:
    description: "'true' when test surface is active"
    value: ${{ steps.plan.outputs.test }}

  bench:
    description: "'true' when bench surface is active"
    value: ${{ steps.plan.outputs.bench }}

  docs:
    description: "'true' when docs surface is active"
    value: ${{ steps.plan.outputs.docs }}

  infra:
    description: "'true' when infra surface is active"
    value: ${{ steps.plan.outputs.infra }}

  custom-surfaces:
    description: "JSON object of custom surface booleans"
    value: ${{ steps.plan.outputs.custom_surfaces }}

  crates:
    description: "Space-separated impacted crates (direct + transitive)"
    value: ${{ steps.plan.outputs.crates }}

  cargo-args:
    description: "Cargo -p flags derived from impacted crates"
    value: ${{ steps.plan.outputs.cargo_args }}

  count:
    description: "Number of impacted crates"
    value: ${{ steps.plan.outputs.count }}

  matrix:
    description: "JSON array of impacted crates (for strategy.matrix)"
    value: ${{ steps.plan.outputs.matrix }}

  changed-files-count:
    description: "Number of changed files"
    value: ${{ steps.plan.outputs.changed_files_count }}

  active-surfaces:
    description: "JSON array of active surfaces"
    value: ${{ steps.plan.outputs.active_surfaces }}

  plan-contract-version:
    description: "Planner contract version used by this run"
    value: ${{ steps.plan.outputs.plan_contract_version }}

  head-ref:
    description: "Resolved planner head reference"
    value: ${{ steps.plan.outputs.head_ref }}

  confidence-profile:
    description: "Effective planner confidence profile"
    value: ${{ steps.plan.outputs.confidence_profile }}

  confidence-profile-source:
    description: "Source of selected confidence profile"
    value: ${{ steps.plan.outputs.confidence_profile_source }}

  # Base Reference (for downstream jobs that need consistent change detection)
  base-ref:
    description: "Git ref used for comparison (set RAIL_SINCE env var for scripts)"
    value: ${{ steps.base.outputs.ref }}

  # Installation Metadata
  install-method:
    description: "How cargo-rail was installed (binary, binstall, cargo-install, cached)"
    value: ${{ steps.plan.outputs.install_method }}

  cargo-rail-version:
    description: "Installed cargo-rail version"
    value: ${{ steps.plan.outputs.cargo_rail_version }}

runs:
  using: "composite"
  steps:
    # Install; Cached > Binary Download > Cargo-Binstall > Cargo Install
    - name: Install cargo-rail
      id: install
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        REQUESTED_VERSION: ${{ inputs.version }}
        CHECKSUM_MODE: ${{ inputs.checksum }}
      run: |
        set -euo pipefail
        MIN_CORE_VERSION="0.9.1"

        require_min_version() {
          local installed="$1"
          local required="$2"
          if ! command -v python3 >/dev/null 2>&1 && ! command -v python >/dev/null 2>&1; then
            echo "::warning::Python not found; skipping cargo-rail minimum version check"
            return 0
          fi
          local py_bin="python3"
          command -v python3 >/dev/null 2>&1 || py_bin="python"
          "$py_bin" -c "
import sys
def parse(v):
    try:
        return tuple(int(x) for x in v.split('.'))
    except:
        return (0, 0, 0)
installed = parse('$installed')
required = parse('$required')
if installed < required:
    print(f'::error::cargo-rail $installed is below required minimum $required for planner contract')
    sys.exit(1)
"
        }

        # Check if already installed and meets version requirement
        if command -v cargo-rail &>/dev/null; then
          INSTALLED_VERSION=$(cargo-rail rail --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "unknown")
          if [[ "$REQUESTED_VERSION" == "latest" || "$INSTALLED_VERSION" == "$REQUESTED_VERSION" ]]; then
            echo "cargo-rail $INSTALLED_VERSION already installed"
            require_min_version "$INSTALLED_VERSION" "$MIN_CORE_VERSION"
            echo "method=cached" >> "$GITHUB_OUTPUT"
            echo "version=$INSTALLED_VERSION" >> "$GITHUB_OUTPUT"
            exit 0
          fi
        fi

        # Determine target triple from runner environment
        case "$RUNNER_OS-$RUNNER_ARCH" in
          Linux-X64)   TARGET="x86_64-unknown-linux-gnu" ;;
          Linux-ARM64) TARGET="aarch64-unknown-linux-gnu" ;;
          macOS-X64)
            echo "::error::macOS x86_64 is not supported; use an Apple Silicon runner (e.g. macos-14)"
            exit 1
            ;;
          macOS-ARM64) TARGET="aarch64-apple-darwin" ;;
          Windows-X64) TARGET="x86_64-pc-windows-msvc" ;;
          Windows-ARM64) TARGET="aarch64-pc-windows-msvc" ;;
          *)
            echo "::warning::Unknown platform $RUNNER_OS-$RUNNER_ARCH, will try cargo install"
            TARGET=""
            ;;
        esac

        # Resolve version (latest -> actual version number)
        VERSION="$REQUESTED_VERSION"
        if [[ "$VERSION" == "latest" ]]; then
          VERSION=$(gh api repos/loadingalias/cargo-rail/releases/latest --jq '.tag_name' 2>/dev/null | sed 's/^v//' || echo "")
          if [[ -z "$VERSION" ]]; then
            echo "::warning::Could not determine latest version from GitHub API"
          fi
        fi

        # Fast path: Pre-built binary download
        if [[ -n "$TARGET" && -n "$VERSION" ]]; then
          echo "Attempting binary download: cargo-rail v$VERSION for $TARGET"

          if [[ "$RUNNER_OS" == "Windows" ]]; then
            ARCHIVE="cargo-rail-${TARGET}.zip"
          else
            ARCHIVE="cargo-rail-${TARGET}.tar.gz"
          fi

          URL="https://github.com/loadingalias/cargo-rail/releases/download/v${VERSION}/${ARCHIVE}"
          INSTALL_DIR="$HOME/.cargo/bin"
          mkdir -p "$INSTALL_DIR"
          calc_sha256 () {
            local file="$1"
            if command -v sha256sum &>/dev/null; then
              sha256sum "$file" | awk '{print $1}'
            elif command -v shasum &>/dev/null; then
              shasum -a 256 "$file" | awk '{print $1}'

            else
              
              if command -v python3 &>/dev/null; then
                python3 -c 'import hashlib,sys; p=sys.argv[1]; h=hashlib.sha256(); f=open(p,"rb"); [h.update(b) for b in iter(lambda: f.read(1024*1024), b"")]; f.close(); print(h.hexdigest())' "$file"
              elif command -v python &>/dev/null; then
                python -c 'import hashlib,sys; p=sys.argv[1]; h=hashlib.sha256(); f=open(p,"rb"); [h.update(b) for b in iter(lambda: f.read(1024*1024), b"")]; f.close(); print(h.hexdigest())' "$file"
              else
                echo "::error::No sha256 tool found (sha256sum/shasum/python)"
                exit 1
              fi
            fi
          }

          verify_checksum () {
            local archive_path="$1"
            local archive_name="$2"
            local mode="${CHECKSUM_MODE:-required}"
          
            case "$mode" in
              off)
                echo "Checksum verification disabled (checksum=off)"
                return 0
                ;;
              required|if-available)
                ;;
              *)
                echo "::error::Invalid checksum mode: $mode. Use required, if-available, or off"
                exit 1
                ;;
            esac
          
            local sums_url="https://github.com/loadingalias/cargo-rail/releases/download/v${VERSION}/SHA256SUMS"
            local sums_path="/tmp/SHA256SUMS-cargo-rail"
          
            if ! curl -fsSL --retry 3 "$sums_url" -o "$sums_path" 2>/dev/null; then
              if [[ "$mode" == "required" ]]; then
                echo "::error::SHA256SUMS not found for v$VERSION; set checksum: if-available or off to skip verification"
                exit 1
              fi
              echo "::warning::SHA256SUMS not found for v$VERSION; skipping checksum verification"
              return 0
            fi
          
            local expected
            expected="$(awk -v f="$archive_name" '$2==f || $2=="*"f {print $1; exit}' "$sums_path" 2>/dev/null || true)"
            if [[ -z "$expected" ]]; then
              echo "::error::SHA256SUMS is present for v$VERSION but has no entry for $archive_name"
              exit 1
            fi
          
            local actual
            actual="$(calc_sha256 "$archive_path")"
            if [[ "$actual" != "$expected" ]]; then
              echo "::error::Checksum mismatch for $archive_name (expected $expected, got $actual)"
              exit 1
            fi
          
            echo "Checksum verified for $archive_name"
          }

          if curl -fsSL --retry 3 "$URL" -o "/tmp/$ARCHIVE"; then
            echo "Downloaded $ARCHIVE"
            verify_checksum "/tmp/$ARCHIVE" "$ARCHIVE"
            echo "Extracting to $INSTALL_DIR..."

            if [[ "$RUNNER_OS" == "Windows" ]]; then
              unzip -q "/tmp/$ARCHIVE" -d "/tmp/cargo-rail-extract"
              mv /tmp/cargo-rail-extract/cargo-rail.exe "$INSTALL_DIR/"
            else
              tar -xf "/tmp/$ARCHIVE" -C "/tmp"
              # Handle both flat and nested archive structures
              if [[ -f "/tmp/cargo-rail" ]]; then
                mv /tmp/cargo-rail "$INSTALL_DIR/"
              elif [[ -f "/tmp/cargo-rail-${TARGET}/cargo-rail" ]]; then
                mv "/tmp/cargo-rail-${TARGET}/cargo-rail" "$INSTALL_DIR/"
              else
                echo "::error::Binary not found after extraction. Contents of /tmp:"
                ls -la /tmp/cargo-rail* 2>/dev/null || echo "No cargo-rail files found"
                exit 1
              fi
              chmod +x "$INSTALL_DIR/cargo-rail"
              echo "Binary installed to $INSTALL_DIR/cargo-rail"
            fi

            rm -rf "/tmp/$ARCHIVE" "/tmp/cargo-rail-extract" "/tmp/cargo-rail" "/tmp/cargo-rail-v"* 2>/dev/null || true

            # Add cargo bin to PATH for this and subsequent steps
            echo "$INSTALL_DIR" >> "$GITHUB_PATH"
            export PATH="$INSTALL_DIR:$PATH"

            # Verify binary works (cargo-rail is a cargo subcommand, use "rail --version")
            if ! "$INSTALL_DIR/cargo-rail" rail --version; then
              echo "::error::cargo-rail binary failed to execute"
              file "$INSTALL_DIR/cargo-rail" || true
              ldd "$INSTALL_DIR/cargo-rail" 2>/dev/null || true
              exit 1
            fi

            INSTALLED_VERSION=$("$INSTALL_DIR/cargo-rail" rail --version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            require_min_version "$INSTALLED_VERSION" "$MIN_CORE_VERSION"
            echo "Installed cargo-rail v$INSTALLED_VERSION from binary"
            echo "method=binary" >> "$GITHUB_OUTPUT"
            echo "version=$INSTALLED_VERSION" >> "$GITHUB_OUTPUT"
            exit 0
          else
            echo "::warning::Binary download failed for $URL"
          fi
        fi

        # Medium path: cargo-binstall (if available)
        if command -v cargo-binstall &>/dev/null; then
          echo "Trying cargo-binstall..."
          BINSTALL_ARGS="--no-confirm --force"
          [[ -n "$VERSION" && "$VERSION" != "latest" ]] && BINSTALL_ARGS="$BINSTALL_ARGS --version $VERSION"

          if cargo binstall cargo-rail $BINSTALL_ARGS 2>/dev/null; then
            INSTALLED_VERSION=$(cargo-rail rail --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            require_min_version "$INSTALLED_VERSION" "$MIN_CORE_VERSION"
            echo "Installed cargo-rail v$INSTALLED_VERSION via cargo-binstall"
            echo "method=binstall" >> "$GITHUB_OUTPUT"
            echo "version=$INSTALLED_VERSION" >> "$GITHUB_OUTPUT"
            exit 0
          fi
        fi

        # Slow path: cargo install (requires Rust toolchain)
        echo "::warning::Falling back to cargo install (this may take 2-5 minutes)"
        INSTALL_ARGS="--locked"
        [[ -n "$VERSION" && "$VERSION" != "latest" ]] && INSTALL_ARGS="$INSTALL_ARGS --version $VERSION"

        cargo install cargo-rail $INSTALL_ARGS

        INSTALLED_VERSION=$(cargo-rail rail --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        require_min_version "$INSTALLED_VERSION" "$MIN_CORE_VERSION"
        echo "Installed cargo-rail v$INSTALLED_VERSION via cargo install"
        echo "method=cargo-install" >> "$GITHUB_OUTPUT"
        echo "version=$INSTALLED_VERSION" >> "$GITHUB_OUTPUT"

    # Detect Base Reference for Comparison; Explicit Input > PR Base > Origin/Main > Origin/Master > HEAD~1
    - name: Detect base ref
      id: base
      shell: bash
      run: |
        INPUT_SINCE="${{ inputs.since }}"

        # Handle null SHA (first push on new branch or force push)
        # GitHub sets before to 0000...0000 in these cases
        if [[ "$INPUT_SINCE" =~ ^0+$ ]]; then
          echo "Null SHA detected (first push or force push), falling back to auto-detect"
          INPUT_SINCE=""
        fi

        if [[ -n "$INPUT_SINCE" ]]; then
          echo "ref=$INPUT_SINCE" >> "$GITHUB_OUTPUT"
          echo "Using provided base: $INPUT_SINCE"
        elif [[ -n "$GITHUB_BASE_REF" ]]; then
          echo "ref=origin/$GITHUB_BASE_REF" >> "$GITHUB_OUTPUT"
          echo "PR detected, using: origin/$GITHUB_BASE_REF"
        elif git rev-parse --verify origin/main &>/dev/null; then
          echo "ref=origin/main" >> "$GITHUB_OUTPUT"
          echo "Using default: origin/main"
        elif git rev-parse --verify origin/master &>/dev/null; then
          echo "ref=origin/master" >> "$GITHUB_OUTPUT"
          echo "Using fallback: origin/master"
        else
          echo "ref=HEAD~1" >> "$GITHUB_OUTPUT"
          echo "::warning::No remote branch found, using HEAD~1"
        fi

    # Run planner and emit selected output mode
    - name: Run cargo-rail plan
      id: plan
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        MODE: ${{ inputs.mode }}
        EXTRA_ARGS: ${{ inputs.args }}
        BASE_REF: ${{ steps.base.outputs.ref }}
        INSTALL_METHOD: ${{ steps.install.outputs.method }}
        INSTALL_VERSION: ${{ steps.install.outputs.version }}
      run: |
        set -euo pipefail

        if [[ "$MODE" != "minimal" && "$MODE" != "full" ]]; then
          echo "::error::invalid mode: $MODE (expected minimal|full)"
          exit 1
        fi

        TMP_OUTPUT="$(mktemp)"
        trap 'rm -f "$TMP_OUTPUT"' EXIT

        cargo rail plan --quiet --since "$BASE_REF" -f github $EXTRA_ARGS -o "$TMP_OUTPUT"

        read_kv() {
          local key="$1"
          grep "^${key}=" "$TMP_OUTPUT" | tail -n1 | cut -d= -f2- || true
        }

        BUILD="$(read_kv build)"
        TEST="$(read_kv test)"
        BENCH="$(read_kv bench)"
        DOCS="$(read_kv docs)"
        INFRA="$(read_kv infra)"
        DIRECT_CRATES="$(read_kv direct_crates)"
        TRANSITIVE_CRATES="$(read_kv transitive_crates)"
        CUSTOM_SURFACES="$(read_kv custom_surfaces)"
        PLAN_CONTRACT_VERSION="$(read_kv plan_contract_version)"
        HEAD_REF="$(read_kv head_ref)"
        CONFIDENCE_PROFILE="$(read_kv confidence_profile)"
        CONFIDENCE_PROFILE_SOURCE="$(read_kv confidence_profile_source)"
        PLAN_JSON="$(read_kv plan_json)"
        FILES="$(read_kv files)"
        CHANGED_FILES_COUNT="$(read_kv changed_files_count)"
        SURFACES="$(read_kv surfaces)"
        TRACE="$(read_kv trace)"
        CRATES="$(read_kv crates)"
        COUNT="$(read_kv count)"
        CARGO_ARGS="$(read_kv cargo_args)"
        MATRIX="$(read_kv matrix)"
        ACTIVE_SURFACES="$(read_kv active_surfaces)"

        if [[ -z "${PLAN_JSON:-}" ]]; then
          echo "::error::planner output missing plan_json"
          exit 1
        fi

        {
          echo "build=${BUILD:-false}"
          echo "test=${TEST:-false}"
          echo "bench=${BENCH:-false}"
          echo "docs=${DOCS:-false}"
          echo "infra=${INFRA:-false}"
          echo "matrix=${MATRIX:-[]}"
          echo "plan_json=${PLAN_JSON}"
        } >> "$GITHUB_OUTPUT"

        if [[ "$MODE" == "full" ]]; then
          {
            echo "direct_crates=${DIRECT_CRATES}"
            echo "transitive_crates=${TRANSITIVE_CRATES}"
            echo "custom_surfaces=${CUSTOM_SURFACES:-{}}"
            echo "plan_contract_version=${PLAN_CONTRACT_VERSION}"
            echo "head_ref=${HEAD_REF}"
            echo "confidence_profile=${CONFIDENCE_PROFILE}"
            echo "confidence_profile_source=${CONFIDENCE_PROFILE_SOURCE}"
            echo "files=${FILES:-[]}"
            echo "changed_files_count=${CHANGED_FILES_COUNT:-0}"
            echo "surfaces=${SURFACES:-{}}"
            echo "trace=${TRACE:-[]}"
            echo "crates=${CRATES}"
            echo "count=${COUNT:-0}"
            echo "cargo_args=${CARGO_ARGS}"
            echo "active_surfaces=${ACTIVE_SURFACES:-[]}"
            echo "install_method=${INSTALL_METHOD}"
            echo "cargo_rail_version=${INSTALL_VERSION}"
          } >> "$GITHUB_OUTPUT"
        fi

    # Generate Job Summary
    - name: Summary
      if: always()
      shell: bash
      env:
        INSTALL_METHOD: ${{ steps.install.outputs.method }}
        INSTALL_VERSION: ${{ steps.install.outputs.version }}
        BASE_REF: ${{ steps.base.outputs.ref }}
        PLAN_JSON: ${{ steps.plan.outputs.plan_json }}
      run: |
        set -euo pipefail
        PYTHON_BIN="python3"
        command -v python3 >/dev/null 2>&1 || PYTHON_BIN="python"
        "$PYTHON_BIN" "${{ github.action_path }}/scripts/render_summary.py" \
          --plan-json "$PLAN_JSON" \
          --install-method "$INSTALL_METHOD" \
          --install-version "$INSTALL_VERSION" \
          --base-ref "$BASE_REF" >> "$GITHUB_STEP_SUMMARY"
