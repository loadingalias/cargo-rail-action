name: "cargo-rail"
description: "Graph-aware change detection for Rust monorepos. Check/Test/Bench/Profile only what actually changed."
author: "loadingalias"

branding:
  icon: "git-branch"
  color: "orange"

inputs:
  version:
    description: "cargo-rail version to install (default: latest)"
    required: false
    default: "latest"

  checksum:
    description: "Checksum verification mode for downloaded binaries: required/if-available/off"
    required: false
    default: "required"

  since:
    description: "Git ref to compare against (auto-detects PR base or origin/main)"
    required: false

  command:
    description: "Command to run: affected/test (default: affected)"
    required: false
    default: "affected"

  args:
    description: "Additional arguments to pass to cargo-rail"
    required: false
    default: ""

  working-directory:
    description: "Working directory containing Cargo.toml (default: repo root)"
    required: false
    default: "."

  token:
    description: "GitHub token for downloading releases"
    required: false
    default: ${{ github.token }}

outputs:
  # Primary Outputs
  crates:
    description: "Space-separated list of affected crates"
    value: ${{ steps.affected.outputs.crates }}

  cargo-args:
    description: "Cargo -p flags for direct use: -p crate1 -p crate2"
    value: ${{ steps.affected.outputs.cargo_args }}

  count:
    description: "Number of affected crates"
    value: ${{ steps.affected.outputs.affected_count }}

  matrix:
    description: "JSON array for strategy.matrix.crate (use with fromJson)"
    value: ${{ steps.affected.outputs.test_matrix }}

  # Classification Flags
  docs-only:
    description: "'true' if only documentation files changed (skip tests)"
    value: ${{ steps.affected.outputs.docs_only }}

  rebuild-all:
    description: "'true' if infrastructure files changed (test everything)"
    value: ${{ steps.affected.outputs.rebuild_all }}

  # Detailed Breakdown
  direct:
    description: "Space-separated crates with direct file changes"
    value: ${{ steps.affected.outputs.direct }}

  transitive:
    description: "Space-separated crates affected via dependencies"
    value: ${{ steps.affected.outputs.transitive }}

  changed-files:
    description: "Number of changed files"
    value: ${{ steps.affected.outputs.changed_files_count }}

  infrastructure-files:
    description: "JSON array of infrastructure files that triggered rebuild_all"
    value: ${{ steps.affected.outputs.infrastructure_files }}

  custom-categories:
    description: "JSON object of custom category matches from rail.toml"
    value: ${{ steps.affected.outputs.custom_categories }}

  # Base Reference (for downstream jobs that need consistent change detection)
  base-ref:
    description: "Git ref used for comparison (set RAIL_SINCE env var for scripts)"
    value: ${{ steps.base.outputs.ref }}

  # Installation Metadata
  install-method:
    description: "How cargo-rail was installed (binary, binstall, cargo-install, cached)"
    value: ${{ steps.install.outputs.method }}

  cargo-rail-version:
    description: "Installed cargo-rail version"
    value: ${{ steps.install.outputs.version }}

runs:
  using: "composite"
  steps:
    # Install; Cached > Binary Download > Cargo-Binstall > Cargo Install
    - name: Install cargo-rail
      id: install
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        REQUESTED_VERSION: ${{ inputs.version }}
        CHECKSUM_MODE: ${{ inputs.checksum }}
      run: |
        set -euo pipefail

        # Check if already installed and meets version requirement
        if command -v cargo-rail &>/dev/null; then
          INSTALLED_VERSION=$(cargo-rail rail --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "unknown")
          if [[ "$REQUESTED_VERSION" == "latest" || "$INSTALLED_VERSION" == "$REQUESTED_VERSION" ]]; then
            echo "cargo-rail $INSTALLED_VERSION already installed"
            echo "method=cached" >> "$GITHUB_OUTPUT"
            echo "version=$INSTALLED_VERSION" >> "$GITHUB_OUTPUT"
            exit 0
          fi
        fi

        # Determine target triple from runner environment
        case "$RUNNER_OS-$RUNNER_ARCH" in
          Linux-X64)   TARGET="x86_64-unknown-linux-gnu" ;;
          Linux-ARM64) TARGET="aarch64-unknown-linux-gnu" ;;
          macOS-X64)
            echo "::error::macOS x86_64 is not supported; use an Apple Silicon runner (e.g. macos-14)"
            exit 1
            ;;
          macOS-ARM64) TARGET="aarch64-apple-darwin" ;;
          Windows-X64) TARGET="x86_64-pc-windows-msvc" ;;
          Windows-ARM64) TARGET="aarch64-pc-windows-msvc" ;;
          *)
            echo "::warning::Unknown platform $RUNNER_OS-$RUNNER_ARCH, will try cargo install"
            TARGET=""
            ;;
        esac

        # Resolve version (latest -> actual version number)
        VERSION="$REQUESTED_VERSION"
        if [[ "$VERSION" == "latest" ]]; then
          VERSION=$(gh api repos/loadingalias/cargo-rail/releases/latest --jq '.tag_name' 2>/dev/null | sed 's/^v//' || echo "")
          if [[ -z "$VERSION" ]]; then
            echo "::warning::Could not determine latest version from GitHub API"
          fi
        fi

        # Fast path: Pre-built binary download
        if [[ -n "$TARGET" && -n "$VERSION" ]]; then
          echo "Attempting binary download: cargo-rail v$VERSION for $TARGET"

          if [[ "$RUNNER_OS" == "Windows" ]]; then
            ARCHIVE="cargo-rail-${TARGET}.zip"
          else
            ARCHIVE="cargo-rail-${TARGET}.tar.gz"
          fi

          URL="https://github.com/loadingalias/cargo-rail/releases/download/v${VERSION}/${ARCHIVE}"
          INSTALL_DIR="$HOME/.cargo/bin"
          mkdir -p "$INSTALL_DIR"
          calc_sha256 () {
            local file="$1"
            if command -v sha256sum &>/dev/null; then
              sha256sum "$file" | awk '{print $1}'
            elif command -v shasum &>/dev/null; then
              shasum -a 256 "$file" | awk '{print $1}'

            else
              
              if command -v python3 &>/dev/null; then
                python3 -c 'import hashlib,sys; p=sys.argv[1]; h=hashlib.sha256(); f=open(p,"rb"); [h.update(b) for b in iter(lambda: f.read(1024*1024), b"")]; f.close(); print(h.hexdigest())' "$file"
              elif command -v python &>/dev/null; then
                python -c 'import hashlib,sys; p=sys.argv[1]; h=hashlib.sha256(); f=open(p,"rb"); [h.update(b) for b in iter(lambda: f.read(1024*1024), b"")]; f.close(); print(h.hexdigest())' "$file"
              else
                echo "::error::No sha256 tool found (sha256sum/shasum/python)"
                exit 1
              fi
            fi
          }

          verify_checksum () {
            local archive_path="$1"
            local archive_name="$2"
            local mode="${CHECKSUM_MODE:-required}"
          
            case "$mode" in
              off)
                echo "Checksum verification disabled (checksum=off)"
                return 0
                ;;
              required|if-available)
                ;;
              *)
                echo "::error::Invalid checksum mode: $mode. Use required, if-available, or off"
                exit 1
                ;;
            esac
          
            local sums_url="https://github.com/loadingalias/cargo-rail/releases/download/v${VERSION}/SHA256SUMS"
            local sums_path="/tmp/SHA256SUMS-cargo-rail"
          
            if ! curl -fsSL --retry 3 "$sums_url" -o "$sums_path" 2>/dev/null; then
              if [[ "$mode" == "required" ]]; then
                echo "::error::SHA256SUMS not found for v$VERSION; set checksum: if-available or off to skip verification"
                exit 1
              fi
              echo "::warning::SHA256SUMS not found for v$VERSION; skipping checksum verification"
              return 0
            fi
          
            local expected
            expected="$(awk -v f="$archive_name" '$2==f || $2=="*"f {print $1; exit}' "$sums_path" 2>/dev/null || true)"
            if [[ -z "$expected" ]]; then
              echo "::error::SHA256SUMS is present for v$VERSION but has no entry for $archive_name"
              exit 1
            fi
          
            local actual
            actual="$(calc_sha256 "$archive_path")"
            if [[ "$actual" != "$expected" ]]; then
              echo "::error::Checksum mismatch for $archive_name (expected $expected, got $actual)"
              exit 1
            fi
          
            echo "Checksum verified for $archive_name"
          }

          if curl -fsSL --retry 3 "$URL" -o "/tmp/$ARCHIVE"; then
            echo "Downloaded $ARCHIVE"
            verify_checksum "/tmp/$ARCHIVE" "$ARCHIVE"
            echo "Extracting to $INSTALL_DIR..."

            if [[ "$RUNNER_OS" == "Windows" ]]; then
              unzip -q "/tmp/$ARCHIVE" -d "/tmp/cargo-rail-extract"
              mv /tmp/cargo-rail-extract/cargo-rail.exe "$INSTALL_DIR/"
            else
              tar -xf "/tmp/$ARCHIVE" -C "/tmp"
              # Handle both flat and nested archive structures
              if [[ -f "/tmp/cargo-rail" ]]; then
                mv /tmp/cargo-rail "$INSTALL_DIR/"
              elif [[ -f "/tmp/cargo-rail-${TARGET}/cargo-rail" ]]; then
                mv "/tmp/cargo-rail-${TARGET}/cargo-rail" "$INSTALL_DIR/"
              else
                echo "::error::Binary not found after extraction. Contents of /tmp:"
                ls -la /tmp/cargo-rail* 2>/dev/null || echo "No cargo-rail files found"
                exit 1
              fi
              chmod +x "$INSTALL_DIR/cargo-rail"
              echo "Binary installed to $INSTALL_DIR/cargo-rail"
            fi

            rm -rf "/tmp/$ARCHIVE" "/tmp/cargo-rail-extract" "/tmp/cargo-rail" "/tmp/cargo-rail-v"* 2>/dev/null || true

            # Add cargo bin to PATH for this and subsequent steps
            echo "$INSTALL_DIR" >> "$GITHUB_PATH"
            export PATH="$INSTALL_DIR:$PATH"

            # Verify binary works (cargo-rail is a cargo subcommand, use "rail --version")
            if ! "$INSTALL_DIR/cargo-rail" rail --version; then
              echo "::error::cargo-rail binary failed to execute"
              file "$INSTALL_DIR/cargo-rail" || true
              ldd "$INSTALL_DIR/cargo-rail" 2>/dev/null || true
              exit 1
            fi

            INSTALLED_VERSION=$("$INSTALL_DIR/cargo-rail" rail --version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            echo "Installed cargo-rail v$INSTALLED_VERSION from binary"
            echo "method=binary" >> "$GITHUB_OUTPUT"
            echo "version=$INSTALLED_VERSION" >> "$GITHUB_OUTPUT"
            exit 0
          else
            echo "::warning::Binary download failed for $URL"
          fi
        fi

        # Medium path: cargo-binstall (if available)
        if command -v cargo-binstall &>/dev/null; then
          echo "Trying cargo-binstall..."
          BINSTALL_ARGS="--no-confirm --force"
          [[ -n "$VERSION" && "$VERSION" != "latest" ]] && BINSTALL_ARGS="$BINSTALL_ARGS --version $VERSION"

          if cargo binstall cargo-rail $BINSTALL_ARGS 2>/dev/null; then
            INSTALLED_VERSION=$(cargo-rail rail --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            echo "Installed cargo-rail v$INSTALLED_VERSION via cargo-binstall"
            echo "method=binstall" >> "$GITHUB_OUTPUT"
            echo "version=$INSTALLED_VERSION" >> "$GITHUB_OUTPUT"
            exit 0
          fi
        fi

        # Slow path: cargo install (requires Rust toolchain)
        echo "::warning::Falling back to cargo install (this may take 2-5 minutes)"
        INSTALL_ARGS="--locked"
        [[ -n "$VERSION" && "$VERSION" != "latest" ]] && INSTALL_ARGS="$INSTALL_ARGS --version $VERSION"

        cargo install cargo-rail $INSTALL_ARGS

        INSTALLED_VERSION=$(cargo-rail rail --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        echo "Installed cargo-rail v$INSTALLED_VERSION via cargo install"
        echo "method=cargo-install" >> "$GITHUB_OUTPUT"
        echo "version=$INSTALLED_VERSION" >> "$GITHUB_OUTPUT"

    # Detect Base Reference for Comparison; Explicit Input > PR Base > Origin/Main > Origin/Master > HEAD~1
    - name: Detect base ref
      id: base
      shell: bash
      run: |
        INPUT_SINCE="${{ inputs.since }}"

        # Handle null SHA (first push on new branch or force push)
        # GitHub sets before to 0000...0000 in these cases
        if [[ "$INPUT_SINCE" =~ ^0+$ ]]; then
          echo "Null SHA detected (first push or force push), falling back to auto-detect"
          INPUT_SINCE=""
        fi

        if [[ -n "$INPUT_SINCE" ]]; then
          echo "ref=$INPUT_SINCE" >> "$GITHUB_OUTPUT"
          echo "Using provided base: $INPUT_SINCE"
        elif [[ -n "$GITHUB_BASE_REF" ]]; then
          echo "ref=origin/$GITHUB_BASE_REF" >> "$GITHUB_OUTPUT"
          echo "PR detected, using: origin/$GITHUB_BASE_REF"
        elif git rev-parse --verify origin/main &>/dev/null; then
          echo "ref=origin/main" >> "$GITHUB_OUTPUT"
          echo "Using default: origin/main"
        elif git rev-parse --verify origin/master &>/dev/null; then
          echo "ref=origin/master" >> "$GITHUB_OUTPUT"
          echo "Using fallback: origin/master"
        else
          echo "ref=HEAD~1" >> "$GITHUB_OUTPUT"
          echo "::warning::No remote branch found, using HEAD~1"
        fi

    # Run Cargo-Rail Command
    - name: Run cargo-rail
      id: affected
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        COMMAND: ${{ inputs.command }}
        EXTRA_ARGS: ${{ inputs.args }}
        BASE_REF: ${{ steps.base.outputs.ref }}
      run: |
        case "$COMMAND" in
          affected)
            cargo rail affected --quiet --since "$BASE_REF" -f github $EXTRA_ARGS -o "$GITHUB_OUTPUT"
            ;;
          test)
            # For test command, run it but also output affected info
            cargo rail affected --quiet --since "$BASE_REF" -f github $EXTRA_ARGS -o "$GITHUB_OUTPUT"
            cargo rail test --quiet --since "$BASE_REF" $EXTRA_ARGS
            ;;
          *)
            echo "::error::Unknown command: $COMMAND. Use 'affected' or 'test'"
            exit 1
            ;;
        esac

        # Generate cargo_args from crates output (requires cargo-rail 0.2.3+)
        # Transform "crate1 crate2 crate3" to "-p crate1 -p crate2 -p crate3"
        CRATES=$(grep "^crates=" "$GITHUB_OUTPUT" 2>/dev/null | cut -d= -f2 || echo "")
        if [[ -n "$CRATES" ]]; then
          CARGO_ARGS=$(echo "$CRATES" | tr ' ' '\n' | sed 's/^/-p /' | tr '\n' ' ' | sed 's/ $//')
          echo "cargo_args=$CARGO_ARGS" >> "$GITHUB_OUTPUT"
        else
          echo "cargo_args=" >> "$GITHUB_OUTPUT"
        fi

    # Generate Job Summary
    - name: Summary
      if: always()
      shell: bash
      run: |
        {
          echo "## cargo-rail"
          echo ""

          # Installation info
          case "${{ steps.install.outputs.method }}" in
            binary)        INSTALL="Binary download" ;;
            binstall)      INSTALL="cargo-binstall" ;;
            cargo-install) INSTALL="cargo install (compiled)" ;;
            cached)        INSTALL="Already installed" ;;
            *)             INSTALL="Unknown" ;;
          esac

          echo "| | |"
          echo "|---|---|"
          echo "| **Version** | \`${{ steps.install.outputs.version }}\` |"
          echo "| **Install** | $INSTALL |"
          echo "| **Base** | \`${{ steps.base.outputs.ref }}\` |"
          echo ""

          # Results
          DOCS_ONLY="${{ steps.affected.outputs.docs_only }}"
          REBUILD_ALL="${{ steps.affected.outputs.rebuild_all }}"
          COUNT="${{ steps.affected.outputs.affected_count }}"
          CRATES="${{ steps.affected.outputs.crates }}"

          if [[ "$DOCS_ONLY" == "true" ]]; then
            echo "> **Documentation only** - no tests required"
          elif [[ "$REBUILD_ALL" == "true" ]]; then
            echo "> **Infrastructure changed** - full test suite recommended"
            echo ""
            echo "| Changed Files | Affected Crates |"
            echo "|---------------|-----------------|"
            echo "| ${{ steps.affected.outputs.changed_files_count }} | **all** |"
          elif [[ "${COUNT:-0}" == "0" ]]; then
            echo "> **No affected crates** - nothing to test"
          else
            echo "| Changed Files | Affected Crates |"
            echo "|---------------|-----------------|"
            echo "| ${{ steps.affected.outputs.changed_files_count }} | **$COUNT** |"
            echo ""
            echo "**Crates:** \`$CRATES\`"

            DIRECT="${{ steps.affected.outputs.direct }}"
            TRANSITIVE="${{ steps.affected.outputs.transitive }}"
            if [[ -n "$DIRECT" ]]; then
              echo ""
              echo "<details><summary>Direct changes</summary>"
              echo ""
              echo "\`$DIRECT\`"
              echo "</details>"
            fi
            if [[ -n "$TRANSITIVE" ]]; then
              echo ""
              echo "<details><summary>Transitive (via dependencies)</summary>"
              echo ""
              echo "\`$TRANSITIVE\`"
              echo "</details>"
            fi
          fi
        } >> "$GITHUB_STEP_SUMMARY"
